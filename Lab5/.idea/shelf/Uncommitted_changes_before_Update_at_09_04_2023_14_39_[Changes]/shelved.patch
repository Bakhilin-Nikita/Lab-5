Index: src/main/java/manager/HelperController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package manager;\r\n\r\nimport object.Coordinates;\r\nimport object.LabWork;\r\nimport object.Person;\r\nimport object.enums.Color;\r\nimport object.enums.Difficulty;\r\nimport parser.Root;\r\nimport parser.parserFromJson.ParserFromJson;\r\nimport parser.parserToJson.ParserToJson;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.text.ParseException;\r\nimport java.time.DateTimeException;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n/**\r\n *\r\n */\r\n\r\npublic class HelperController {\r\n    private Root root; // Не может быть null\r\n    private ArrayList<String> paths = new ArrayList<>(); // Не может быть null\r\n    private BufferedReader reader; // Не может быть null\r\n\r\n    private final String fileName;\r\n\r\n    /**\r\n     * Конструктор создает объект который выгружает данные из файла в нашу переменную.\r\n     * Устанавливает директорию корневую.\r\n     */\r\n    public HelperController(String file, Root root) throws IOException {\r\n        this.fileName = file;\r\n        ParserFromJson parserFromJson = new ParserFromJson();\r\n        this.root = root;\r\n        this.reader = new BufferedReader(new InputStreamReader(System.in));\r\n        this.paths.add(System.getProperty(\"user.dir\"));\r\n    }\r\n\r\n    /**\r\n     * Метод позволяет добавить в коллекцию путь которого еще не было в коллекции\r\n     * Относится к методу execute_script.\r\n     * Если пути еще не было вернет true, иначе false\r\n     *\r\n     * @param pathToFile\r\n     * @return\r\n     */\r\n    public boolean addToPaths(String pathToFile) {\r\n        pathToFile = System.getProperty(\"user.dir\") + \"/\" + pathToFile;\r\n        for (int i = 0; i < getPaths().size(); i++) {\r\n            if (Objects.equals(getPaths().get(i).trim(), pathToFile)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        getPaths().add(pathToFile);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Метод обновляет объект который находится в коллекции, по его id\r\n     * При это не изменяя его id.\r\n     * Цикл for прогоняется по коллекции, если id найдено, то меняем поля.\r\n     *\r\n     * @param id\r\n     * @throws IOException\r\n     * @throws ParseException\r\n     */\r\n    public void update(int id) throws IOException, ParseException {\r\n        boolean flag = true;\r\n        for (LabWork lab : getRoot().getLabWorkSet()) {\r\n            if (lab.getId() == id) {\r\n                System.out.println(\"Введите название Лабараторной работы: \");\r\n                String name = reader.readLine();\r\n                Coordinates coordinates = addCoordinates();\r\n                Person author = addPerson();\r\n                int minimalPoint = addMinimalPoint();\r\n                int tunedInWorks = addTunedInWorks();\r\n                Difficulty difficulty = addDifficulty();\r\n                LabWork e = new LabWork(name, minimalPoint, tunedInWorks, difficulty, coordinates, author);\r\n\r\n                lab.setName(e.getName());\r\n\r\n                lab.setAuthor(e.getAuthor());\r\n                lab.setCoordinates(e.getCoordinates());\r\n                lab.setDifficulty(e.getDifficulty());\r\n                lab.setMinimalPoint(e.getMinimalPoint());\r\n                lab.setTunedInWorks(e.getTunedInWorks());\r\n                System.out.println(\"Элемент успешно добавлен в коллекцию!\");\r\n                flag = false;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            System.out.println(\"Элемент с данным ID отсутствует!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод показывает все элементы коллекции.\r\n     * Сортируя их по id\r\n     */\r\n    public void show() {\r\n        List<LabWork> labWorkList = new ArrayList<>();\r\n        labWorkList.addAll(getRoot().getLabWorkSet());\r\n\r\n        if (labWorkList.isEmpty()) {\r\n            System.out.println(\"Коллекция пустая\");\r\n        } else {\r\n            labWorkList.sort(compareByID);\r\n            for (LabWork lab : labWorkList) {\r\n                System.out.println(lab);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Дополнительный метод для {@link #getInfo()}\r\n     *\r\n     * @return\r\n     */\r\n    private LocalDate getCreationDate() {\r\n        List<LabWork> labWorkList = new ArrayList<>();\r\n        labWorkList.addAll(getRoot().getLabWorkSet());\r\n        LabWork minimum = Collections.min(labWorkList, compareByID);\r\n        return minimum.getCreationDate().toLocalDate();\r\n    }\r\n\r\n    /**\r\n     * Метод info: получение информации о коллекции\r\n     */\r\n    public void getInfo() {\r\n        if (getRoot().getLabWorkSet().isEmpty()) {\r\n            System.out.println(\"Информация по коллекции не найдена! Возможно она удаленна.\");\r\n        } else {\r\n            System.out.println(\"Тип коллекции: \" + getRoot().getLabWorkSet().getClass().getSimpleName());\r\n            System.out.println(\"Дата инициализации: \" + getCreationDate());\r\n            System.out.println(\"Количество элементов: \" + getRoot().getLabWorkSet().size());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод удаляет из коллекции все элементы, превышающие заданный.\r\n     *\r\n     * @param e\r\n     */\r\n    public void removeGreater(String e) {\r\n        List<LabWork> labWorkList = new ArrayList<>(getRoot().getLabWorkSet());\r\n        labWorkList.sort(compareByMinPointReverse);\r\n        for (LabWork el : labWorkList) {\r\n            if (el.getName().equals(e)) {\r\n                break;\r\n            }\r\n            getRoot().getLabWorkSet().remove(el);\r\n        }\r\n        System.out.println(\"Все элементы выше данного, были удаленны.\");\r\n    }\r\n\r\n    /**\r\n     * Метод удаляет все элементы меньшие чем заданный.\r\n     *\r\n     * @param e\r\n     */\r\n    public void removeLower(String e) {\r\n        List<LabWork> labWorkList = new ArrayList<>();\r\n        labWorkList.addAll(getRoot().getLabWorkSet());\r\n        labWorkList.sort(compareByName);\r\n\r\n        for (LabWork el : labWorkList) {\r\n            if (el.getName().equals(e)) {\r\n                break;\r\n            }\r\n            getRoot().getLabWorkSet().remove(el);\r\n        }\r\n\r\n        System.out.println(\"Все элементы меньше данного были удалены.\");\r\n    }\r\n\r\n    /**\r\n     * Метод удаляет элемент коллекции по id.\r\n     */\r\n    public void removeEl(int id) {\r\n        int flag = 0;\r\n        for (LabWork lab : getRoot().getLabWorkSet()) {\r\n            if (lab.getId() == id) {\r\n                getRoot().getLabWorkSet().remove(lab);\r\n                flag = 1;\r\n                System.out.println(\"Элемент с данными id удалён.\");\r\n                break;\r\n            }\r\n        }\r\n        if (flag == 0) {\r\n            System.out.println(\"Элемент с данным id не найден!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод добавляет элемент в коллекцию\r\n     *\r\n     * @throws IOException\r\n     * @throws ParseException\r\n     * @see #addCoordinates()\r\n     * @see #addCoordinates()\r\n     * @see #addMinimalPoint()\r\n     * @see #addTunedInWorks()\r\n     * @see #addPerson()\r\n     */\r\n    public void addElement(String e) throws IOException {\r\n        System.out.println(\"Введите название Лабараторной работы: \");\r\n        String name = reader.readLine();\r\n        Coordinates coordinates = addCoordinates();\r\n        Person author = addPerson();\r\n        int minimalPoint = addMinimalPoint();\r\n        int tunedInWorks = addTunedInWorks();\r\n        Difficulty difficulty = addDifficulty();\r\n        int id = generateId();\r\n        LabWork lab = new LabWork(id, name, minimalPoint, tunedInWorks, difficulty, coordinates, author);\r\n\r\n        if (getRoot().getLabWorkSet().add(lab))\r\n            System.out.println(\"Элемент успешно добавлен в коллекцию!\");\r\n        else\r\n            System.out.println(\"К сожалению, что-то пошло не так. Попробуйте еще раз!\");\r\n    }\r\n\r\n    /**\r\n     * Метод генерирует id нового объекта\r\n     *\r\n     * @return\r\n     */\r\n    public int generateId() {\r\n        Map<Integer, LabWork> labs = new HashMap<>();\r\n        for (LabWork lab : getRoot().getLabWorkSet())\r\n            labs.put((int) lab.getId(), lab);\r\n        labs = sortByKeys(labs);\r\n        return labs.size() + 1;\r\n    }\r\n\r\n    /**\r\n     * Сортирует коллекцию объектов по ключу.\r\n     *\r\n     * @param unsortedMap\r\n     * @param <K>\r\n     * @param <V>\r\n     * @return\r\n     */\r\n    public <K, V> Map<K, V> sortByKeys(Map<K, V> unsortedMap) {\r\n        return new TreeMap<>(unsortedMap);\r\n    }\r\n\r\n\r\n    /**\r\n     * Добавить элемент в коллекцию, если он больше остальных. Сравнивая по\r\n     *\r\n     * @param name\r\n     * @throws IOException\r\n     * @throws ParseException\r\n     */\r\n    public void addIfMax(String name) throws IOException, ParseException {\r\n        Coordinates coordinates = addCoordinates();\r\n        Person author = addPerson();\r\n        int minimalPoint = addMinimalPoint();\r\n        int tunedInWorks = addTunedInWorks();\r\n        Difficulty difficulty = addDifficulty();\r\n        LabWork e = new LabWork(name, minimalPoint, tunedInWorks, difficulty, coordinates, author);\r\n        LabWork maximum = Collections.max(getRoot().getLabWorkSet(), compareByMinPoint);\r\n        if ((e.getMinimalPoint() - maximum.getMinimalPoint()) > 0) {\r\n            getRoot().getLabWorkSet().add(e);\r\n            System.out.println(\"Элемент добавлен в коллекцию\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод обрабатывает поле\r\n     * Дополнительный метод для {@link #addElement(String)}\r\n     *\r\n     * @return\r\n     */\r\n    private Integer addTunedInWorks() throws IOException {\r\n        Integer tunedInWorks = null;\r\n        boolean flag = false;\r\n        System.out.println(\"Введите tunedInWorks(1-1000):\");\r\n        String commandValue = reader.readLine();\r\n        if (!commandValue.trim().isEmpty())\r\n            while (!flag) {\r\n                    try {\r\n                        if (commandValue != null) {\r\n                            tunedInWorks = Integer.parseInt(commandValue);\r\n                        } else {\r\n                            System.out.println(\"Введите tunedInWorks(1-1000):\");\r\n                            tunedInWorks = checkOnInt();\r\n                        }\r\n                        if (tunedInWorks > 0 && tunedInWorks < 1001) {\r\n                            flag = true;\r\n                        }\r\n                        commandValue = null;\r\n                    } catch (NumberFormatException e) {\r\n                        System.out.println(e.getMessage());\r\n                    }\r\n                }\r\n\r\n\r\n        return tunedInWorks;\r\n    }\r\n\r\n    /**\r\n     * Метод обрабатывает поле {@link LabWork#minimalPoint}\r\n     * Дополнительный метод для {@link #addElement(String)}\r\n     *\r\n     * @return\r\n     */\r\n    private int addMinimalPoint() {\r\n        int minimalPoint = 0;\r\n        boolean flag = false;\r\n        while (!flag) {\r\n            System.out.println(\"Введите minimalPoint(1-1000):\");\r\n            minimalPoint = checkOnInt();\r\n            if (minimalPoint > 0 && minimalPoint < 1001)\r\n                flag = true;\r\n            else\r\n                System.out.println(\"Вы ввели неккоректное число! Число не может быть отрицательным, или равно нулю.\");\r\n        }\r\n\r\n        return minimalPoint;\r\n    }\r\n\r\n    /**\r\n     * Метод обрабатывает поле {@link LabWork#coordinates}\r\n     * Дополнительный метод для {@link #addElement(String)}\r\n     *\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    private Coordinates addCoordinates() throws IOException {\r\n        System.out.println(\"Введите координату x:\");\r\n        int x = checkOnInt();\r\n        System.out.println(\"Введите координату y:\");\r\n        double y = checkOnDouble();\r\n\r\n        return new Coordinates(x, y);\r\n    }\r\n\r\n    /**\r\n     * Метод сохраняет коллекцию в файл.\r\n     */\r\n    public void save() {\r\n        ParserToJson parserToJson = new ParserToJson();\r\n\r\n        if (parserToJson.serialization(getRoot().getLabWorkSet(), this.fileName))\r\n            System.out.println(\"Коллекция \" + getRoot().getLabWorkSet().getClass().getSimpleName() + \" успешно сохранена в файл!\");\r\n        else\r\n            System.out.println(\"Что-то пошлое не так :(\");\r\n    }\r\n\r\n    /**\r\n     * Доп метод для {@link #addElement(String)}: добавить сложность\r\n     *\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    private Difficulty addDifficulty() {\r\n        System.out.println(\"Введите сложность работы (VERY_EASY, EASY, VERY_HARD, IMPOSSIBLE, HOPELESS:\");\r\n        String difficulty = checkOnEnum(Difficulty.class);\r\n        return Difficulty.valueOf(difficulty);\r\n    }\r\n\r\n\r\n    /**\r\n     * Доп метод для {@link #addElement(String)}: добавить автора\r\n     *\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    private Person addPerson() throws IOException {\r\n        System.out.println(\"Введите имя автора: \");\r\n        String name = reader.readLine();\r\n\r\n        boolean flag = false;\r\n        float height = 0;\r\n        while (!flag) {\r\n            System.out.println(\"Введите рост автора: \");\r\n            float h = checkOnFloat();\r\n            h = (float) Math.floor(h);\r\n            if (h > 67.08 && h < 272) {\r\n                flag = true;\r\n                height = h;\r\n            } else {\r\n                System.out.println(\"Вы ввели неправильный рост! Доступно в интервале 67.08 до 272.\");\r\n            }\r\n        }\r\n\r\n        String date = null;\r\n        LocalDate birthday = null;\r\n        while (date == null) {\r\n            try {\r\n                System.out.println(\"Введите дату рождения автора (гггг-мм-дд): \");\r\n                birthday = LocalDate.parse(reader.readLine());\r\n                String[] dateSplit = birthday.toString().split(\"-\");\r\n                if (Integer.parseInt(dateSplit[0]) >= 1907 && Integer.parseInt(dateSplit[0]) < 2015)\r\n                    date = dateSplit[2] + \"-\" + dateSplit[1] + \"-\" + dateSplit[0];\r\n                else\r\n                    System.out.println(\"Ты не мог родиться в такой год. Самый старый человек родился в 1907 году.Мария Браньяс Морера\");\r\n            } catch (DateTimeException e) {\r\n                System.out.println(e.getMessage());\r\n            }\r\n        }\r\n\r\n        System.out.println(\"Введите цвет глаз автора (GREEN, RED, ORANGE, WHITE, BLACK): \");\r\n\r\n        String color = checkOnEnum(Color.class);\r\n\r\n        return new Person(name, Color.valueOf(color), height, date);\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет является ли число типом {@link Double}\r\n     *\r\n     * @return\r\n     */\r\n    private double checkOnDouble() {\r\n        double y = 0;\r\n        boolean flag = false;\r\n        while (!flag) {\r\n            try {\r\n                y = Double.parseDouble(reader.readLine());\r\n                flag = true;\r\n            } catch (IOException | NumberFormatException e) {\r\n                flag = false;\r\n            }\r\n        }\r\n\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет является ли число типом {@link Integer}\r\n     *\r\n     * @return\r\n     */\r\n    private int checkOnInt() {\r\n        int y = 0;\r\n        boolean flag = false;\r\n        while (!flag)\r\n            try {\r\n                y = Integer.parseInt(reader.readLine());\r\n                flag = true;\r\n            } catch (NumberFormatException | IOException e) {\r\n                flag = false;\r\n            }\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет является ли число типом {@link Enum}\r\n     *\r\n     * @return\r\n     */\r\n    private String checkOnEnum(Class className) {\r\n        boolean flag = false;\r\n        String enumValue = null;\r\n        while (!flag) {\r\n            try {\r\n                enumValue = reader.readLine().toUpperCase();\r\n                Enum.valueOf(className, enumValue);\r\n                flag = true;\r\n            } catch (IllegalArgumentException | IOException e) {\r\n                flag = false;\r\n            }\r\n        }\r\n\r\n        return enumValue;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет является ли число типом {@link Float}\r\n     *\r\n     * @return\r\n     */\r\n    private float checkOnFloat() {\r\n        float y = 0;\r\n        boolean flag = false;\r\n        while (!flag)\r\n            try {\r\n                String cmd = reader.readLine();\r\n                if (cmd != null) {\r\n                    y = Float.parseFloat(cmd);\r\n                    flag = true;\r\n                }\r\n            } catch (NumberFormatException | IOException e) {\r\n                flag = false;\r\n            }\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Метод производит очистку коллекции.\r\n     */\r\n    public void clearCollection() {\r\n        getRoot().getLabWorkSet().clear();\r\n        if (getRoot().getLabWorkSet().isEmpty())\r\n            System.out.println(\"Коллекция \" + getRoot().getLabWorkSet().getClass().getSimpleName() + \" очищена!\");\r\n    }\r\n\r\n    /**\r\n     * Сравнение авторов по имени, вывод максимального.\r\n     */\r\n    public void maxByAuthor() {\r\n        List<Person> authors = new ArrayList<>();\r\n\r\n        if (!getRoot().getLabWorkSet().isEmpty()) {\r\n            // вывести в метод\r\n            for (LabWork lab : getRoot().getLabWorkSet()) {\r\n                authors.add(lab.getAuthor());\r\n            }\r\n            Comparator<Person> compareByName = new Comparator<Person>() {\r\n                @Override\r\n                public int compare(Person o1, Person o2) {\r\n                    return o1.getName().compareTo(o2.getName());\r\n                }\r\n            };\r\n            Person greatest = Collections.max(authors, compareByName);\r\n            System.out.println(\" ----- Автор -----\");\r\n            System.out.println(\"Uмя: \" + greatest.getName());\r\n            System.out.println(\"Дата рождения: \" + greatest.getBirthday());\r\n            System.out.println(\"Рост: \" + greatest.getHeight());\r\n            System.out.println(\"Цвет глаз: \" + greatest.getEyeColor());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Вывести уникальные значения tunedInWorks\r\n     */\r\n    public void printUniqueTunedInWorks() {\r\n        Set<Integer> unique = new HashSet<>();\r\n        for (LabWork lab : getRoot().getLabWorkSet()) {\r\n            unique.add(lab.getTunedInWorks());\r\n        }\r\n\r\n        printCollection(unique);\r\n        System.out.println(\"\\n\");\r\n    }\r\n\r\n    /**\r\n     * Доп метод для вывода коллекции элементов в {@link #printFieldAscendingTunedInWorks()}\r\n     *\r\n     * @param collection\r\n     */\r\n    private void printCollection(Collection<Integer> collection) {\r\n        collection.forEach(System.out::println);\r\n    }\r\n\r\n    /**\r\n     * Вывести значения {@link LabWork#tunedInWorks} в порядке возрастания\r\n     */\r\n    public void printFieldAscendingTunedInWorks() {\r\n        List<Integer> tunedInWorks = new LinkedList<>();\r\n        for (LabWork lab : getRoot().getLabWorkSet()) {\r\n            tunedInWorks.add(lab.getTunedInWorks());\r\n        }\r\n\r\n        Collections.sort(tunedInWorks);\r\n\r\n        printCollection(tunedInWorks);\r\n\r\n\r\n        System.out.println(\"\\n\");\r\n    }\r\n\r\n\r\n    Comparator<LabWork> compareByName = new Comparator<LabWork>() {\r\n        @Override\r\n        public int compare(LabWork o1, LabWork o2) {\r\n            return o1.getName().length() - o2.getName().length();\r\n        }\r\n    };\r\n\r\n    //компаратор для сравнения элементов коллекции. В качестве элемента сравнения беру поле minimalPoint\r\n    Comparator<LabWork> compareByMinPoint = new Comparator<LabWork>() {\r\n        @Override\r\n        public int compare(LabWork o1, LabWork o2) {\r\n            return o1.getMinimalPoint() - o2.getMinimalPoint();\r\n        }\r\n    };\r\n\r\n    //то же, но если в первом случае было сравнение по возрастанию, то здесь по убыванию\r\n    Comparator<LabWork> compareByMinPointReverse = new Comparator<LabWork>() {\r\n        @Override\r\n        public int compare(LabWork o1, LabWork o2) {\r\n            return o2.getMinimalPoint() - o1.getMinimalPoint();\r\n        }\r\n    };\r\n\r\n    //компаратор для сравнения элементов по ID\r\n    Comparator<LabWork> compareByID = new Comparator<LabWork>() {\r\n        @Override\r\n        public int compare(LabWork o1, LabWork o2) {\r\n            return (int) (o1.getId() - o2.getId());\r\n        }\r\n    };\r\n\r\n    public ArrayList<String> getPaths() {\r\n        return paths;\r\n    }\r\n\r\n    public void setPaths(ArrayList<String> paths) {\r\n        this.paths = paths;\r\n    }\r\n\r\n    public Root getRoot() {\r\n        return root;\r\n    }\r\n\r\n    public void setReader(BufferedReader reader) {\r\n        this.reader = reader;\r\n    }\r\n\r\n    public BufferedReader getReader() {\r\n        return reader;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"HelperController{\" +\r\n                \"root=\" + root +\r\n                \", paths=\" + paths +\r\n                \", reader=\" + reader +\r\n                \", compareByName=\" + compareByName +\r\n                \", compareByMinPoint=\" + compareByMinPoint +\r\n                \", compareByMinPointReverse=\" + compareByMinPointReverse +\r\n                \", compareByID=\" + compareByID +\r\n                '}';\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/manager/HelperController.java b/src/main/java/manager/HelperController.java
--- a/src/main/java/manager/HelperController.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/manager/HelperController.java	(date 1680385862139)
@@ -1,5 +1,6 @@
 package manager;
 
+import exceptions.InvalidFieldY;
 import object.Coordinates;
 import object.LabWork;
 import object.Person;
@@ -337,10 +338,22 @@
      * @throws IOException
      */
     private Coordinates addCoordinates() throws IOException {
+        boolean flag = false;
         System.out.println("Введите координату x:");
         int x = checkOnInt();
-        System.out.println("Введите координату y:");
-        double y = checkOnDouble();
+        double y = 0;
+        while(!flag) {
+            try {
+                System.out.println("Введите координату y:");
+                y = checkOnDouble();
+                if (y < -184) {
+                    throw new InvalidFieldY("Field Y must be > -184 and con not be NULL");
+                }
+                flag = true;
+            } catch (InvalidFieldY e) {
+                System.out.println(e.getMessage());
+            }
+        }
 
         return new Coordinates(x, y);
     }
@@ -385,7 +398,6 @@
         while (!flag) {
             System.out.println("Введите рост автора: ");
             float h = checkOnFloat();
-            h = (float) Math.floor(h);
             if (h > 67.08 && h < 272) {
                 flag = true;
                 height = h;
Index: src/main/java/object/LabWork.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package object;\r\n\r\nimport object.enums.Difficulty;\r\n\r\nimport java.time.ZonedDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.Locale;\r\nimport java.util.Objects;\r\n\r\n/**\r\n * The object.LabWork is main object for console App\r\n */\r\n\r\npublic class LabWork {\r\n\r\n    private int id; //Значение поля должно быть больше 0, Значение этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически\r\n    private String name; //Поле не может быть null, Строка не может быть пустой\r\n    private Coordinates coordinates = new Coordinates(); //Поле не может быть null\r\n    //Поле не может быть null, Значение этого поля должно генерироваться автоматически\r\n    private int minimalPoint; //Значение поля должно быть больше 0\r\n    private int tunedInWorks;\r\n    private Difficulty difficulty; //Поле может быть null\r\n    private Person author; //Поле не может быть null\r\n\r\n    private String creationDateString;  //Поле не может быть null, Значение этого поля должно генерироваться автоматически\r\n\r\n    public LabWork(int id, String name, int minimalPoint, int tunedInWorks, Difficulty difficulty, Coordinates coordinates, Person author, String creationDateString) {\r\n        this.id = id;\r\n        this.name = Objects.requireNonNull(name);\r\n        this.coordinates = Objects.requireNonNull(coordinates);\r\n        this.minimalPoint = minimalPoint;\r\n        this.author = Objects.requireNonNull(author);\r\n        this.tunedInWorks = tunedInWorks; // I do not understand what is it\r\n        this.difficulty = Objects.requireNonNull(difficulty);\r\n\r\n        if (creationDateString.isEmpty()) {\r\n            ZonedDateTime date = ZonedDateTime.now();\r\n\r\n            DateTimeFormatter formatter = DateTimeFormatter.\r\n                    ofPattern(DateTimeFormatter.\r\n                            ofPattern(\"MM/dd/yyyy - HH:mm:ss Z\").\r\n                            format(date));\r\n            this.creationDateString = date.format(formatter);\r\n        } else {\r\n            this.creationDateString = creationDateString;\r\n        }\r\n    }\r\n\r\n    public LabWork(int id, String name, int minimalPoint, int tunedInWorks, Difficulty difficulty, Coordinates coordinates, Person author) {\r\n        this.id = id;\r\n        this.name = Objects.requireNonNull(name);\r\n        this.coordinates = Objects.requireNonNull(coordinates);\r\n        this.minimalPoint = minimalPoint;\r\n        this.author = Objects.requireNonNull(author);\r\n        this.tunedInWorks = tunedInWorks;\r\n        this.difficulty = Objects.requireNonNull(difficulty);\r\n\r\n\r\n        ZonedDateTime date = ZonedDateTime.now();\r\n\r\n        DateTimeFormatter formatter = DateTimeFormatter.\r\n                ofPattern(DateTimeFormatter.\r\n                        ofPattern(\"MM/dd/yyyy - HH:mm:ss Z\").\r\n                        format(date));\r\n        this.creationDateString = date.format(formatter);\r\n    }\r\n\r\n    public LabWork(String name, int minimalPoint, int tunedInWorks, Difficulty difficulty, Coordinates coordinates, Person author) {\r\n        this.name = Objects.requireNonNull(name);\r\n        this.coordinates = Objects.requireNonNull(coordinates);\r\n        this.minimalPoint = minimalPoint;\r\n        this.author = Objects.requireNonNull(author);\r\n        this.tunedInWorks = tunedInWorks; // I do not understand what is it\r\n        this.difficulty = Objects.requireNonNull(difficulty);\r\n        ZonedDateTime date = ZonedDateTime.now();\r\n\r\n        DateTimeFormatter formatter = DateTimeFormatter.\r\n                ofPattern(DateTimeFormatter.\r\n                        ofPattern(\"MM/dd/yyyy - HH:mm:ss Z\").\r\n                        format(date));\r\n        this.creationDateString = date.format(formatter);\r\n    }\r\n\r\n    public ZonedDateTime getCreationDate() {\r\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM/dd/yyyy - HH:mm:ss Z\");\r\n        formatter = formatter.withLocale(Locale.US);  // Locale specifies human language for translating, and cultural norms for lowercase/uppercase and abbreviations and such. Example: Locale.US or Locale.CANADA_FRENCH\r\n        ZonedDateTime date = ZonedDateTime.parse(this.creationDateString, formatter);\r\n        return date;\r\n    }\r\n\r\n\r\n    public String getCreationDateString() {\r\n        return creationDateString;\r\n    }\r\n\r\n    public void setDifficulty(Difficulty diff) {\r\n        this.difficulty = diff;\r\n    }\r\n\r\n    public Difficulty getDifficulty() {\r\n        return difficulty;\r\n    }\r\n\r\n    public long getId() {\r\n        return this.id;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setAuthor(Person author) {\r\n        this.author = author;\r\n    }\r\n\r\n    public Person getAuthor() {\r\n        return this.author;\r\n    }\r\n\r\n    public void setCoordinates(Coordinates coordinates) {\r\n        this.coordinates = coordinates;\r\n    }\r\n\r\n    public Coordinates getCoordinates() {\r\n        return this.coordinates;\r\n    }\r\n\r\n    public void setMinimalPoint(int minimalPoint) {\r\n        this.minimalPoint = minimalPoint;\r\n    }\r\n\r\n    public int getMinimalPoint() {\r\n        return this.minimalPoint;\r\n    }\r\n\r\n    public void setTunedInWorks(int tunedInWorks) {\r\n        this.tunedInWorks = tunedInWorks;\r\n    }\r\n\r\n    public int getTunedInWorks() {\r\n        return this.tunedInWorks;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"id:\" + id + \"\\n\" +\r\n                \"name:\" + name + \"\\n\" +\r\n                \"coordinates:\" + \"\\n\" +\r\n                \"creationDate:\" + creationDateString + \"\\n\" +\r\n                \"[x=\" + getCoordinates().getX() + \"\\n\" +\r\n                \"y=\" + getCoordinates().getY() + \"]\" + \"\\n\" +\r\n                \"minimalPoint=\" + minimalPoint + \"\\n\" +\r\n                \"tunedInWorks=\" + tunedInWorks + \"\\n\" +\r\n                \"difficulty=\" + difficulty + \"\\n\" +\r\n                \"author:\" + \"\\n\" +\r\n                \"[name=\" + author.getName() + \"\\n\" +\r\n                \"birthday=\" + author.getBirthday() + \"\\n\" +\r\n                \"height=\" + author.getHeight() + \"\\n\" +\r\n                \"eyeColor=\" + author.getEyeColor() + \"]\\n\" +\r\n                \"---------------------\";\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/object/LabWork.java b/src/main/java/object/LabWork.java
--- a/src/main/java/object/LabWork.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/object/LabWork.java	(date 1680366429454)
@@ -149,8 +149,8 @@
     public String toString() {
         return "id:" + id + "\n" +
                 "name:" + name + "\n" +
-                "coordinates:" + "\n" +
                 "creationDate:" + creationDateString + "\n" +
+                "coordinates:" + "\n" +
                 "[x=" + getCoordinates().getX() + "\n" +
                 "y=" + getCoordinates().getY() + "]" + "\n" +
                 "minimalPoint=" + minimalPoint + "\n" +
Index: src/main/java/command/commands/inputCommands/RemoveGreaterElementCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package command.commands.inputCommands;\r\n\r\n\r\nimport command.Command;\r\nimport command.ElementCommand;\r\nimport manager.HelperController;\r\n\r\npublic class RemoveGreaterElementCommand implements Command {\r\n    private HelperController helperController;\r\n\r\n    public RemoveGreaterElementCommand(HelperController helperController) {\r\n        this.helperController = helperController;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        helperController.removeGreater();\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/command/commands/inputCommands/RemoveGreaterElementCommand.java b/src/main/java/command/commands/inputCommands/RemoveGreaterElementCommand.java
--- a/src/main/java/command/commands/inputCommands/RemoveGreaterElementCommand.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/command/commands/inputCommands/RemoveGreaterElementCommand.java	(date 1680366017470)
@@ -14,7 +14,7 @@
 
     @Override
     public void execute() {
-        helperController.removeGreater();
+   //     helperController.removeGreater();
     }
 }
 
Index: src/main/java/App.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import manager.Controller;\r\n\r\nimport java.io.IOException;\r\nimport java.text.ParseException;\r\n\r\n/**\r\n * App запускающий класс, содержащий метод {@link #main(String[])}\r\n */\r\n\r\npublic class App {\r\n\r\n    /**\r\n     * Главный  метод, который запускает {@link Controller#start()}\r\n     *\r\n     * @param args\r\n     * @throws IOException\r\n     */\r\n    public static void main(String[] args) throws IOException, ParseException {\r\n        Controller controller = new Controller(args[0]);\r\n        controller.start();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/App.java b/src/main/java/App.java
--- a/src/main/java/App.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/App.java	(date 1680373698976)
@@ -16,7 +16,14 @@
      * @throws IOException
      */
     public static void main(String[] args) throws IOException, ParseException {
-        Controller controller = new Controller(args[0]);
+        String file;
+        try{
+            file = args[0];
+        } catch (IndexOutOfBoundsException e) {
+            file = "notes.json";
+        }
+
+        Controller controller = new Controller(file);
         controller.start();
     }
 }
Index: src/main/java/manager/Controller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package manager;\r\n\r\nimport command.commands.*;\r\nimport command.commands.noInputCommands.help.*;\r\nimport command.inputCmdCollection.*;\r\nimport command.noInputCmdCollection.NoInputCommands;\r\nimport object.LabWork;\r\nimport org.apache.commons.lang3.text.WordUtils;\r\nimport parser.Root;\r\nimport parser.parserFromJson.ParserFromJson;\r\nimport java.io.*;\r\nimport java.text.ParseException;\r\nimport java.util.*;\r\n\r\n/**\r\n * @see Controller нужен для вызова команд. Из него уже происходит вся работа программы.\r\n * Ключевой класс программы.\r\n */\r\n\r\npublic class Controller {\r\n    private final String file;\r\n    private Map<String, Invoker> commands = new HashMap<>(); // Map для команд БЕЗ входных данных, не может быть null\r\n    private Map<String, Invoker> inputCommands = new HashMap<>(); // Map для команд С входными данными, не может быть null\r\n    private HashSet<LabWork> labWorks = new HashSet<>(); // Коллекция объектов, не может быть null\r\n    private ParserFromJson parserFromJson = new ParserFromJson(); // Парсинг в коллекцию. Не может быть null\r\n    private GetHelpCommand help = new GetHelpCommand(new Information()); // Не может быть null\r\n    private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  // Не может быть null\r\n    private HelperController helperController; // Не может быть null\r\n    private Root root; // Не может быть null\r\n    private ExecuteScript executeScript; // Не может быть null\r\n\r\n\r\n    /**\r\n     * В конструкторе происходит автоматическая проверка json-файла.\r\n     * Если в файле есть хотя бы один обьект класса LabWork он подгружается в коллекцию LabWorks класса\r\n     *\r\n     * @throws FileNotFoundException\r\n     * @see LabWork\r\n     */\r\n    public Controller(String file) throws IOException {\r\n        this.file = file;\r\n        if (parserFromJson.checkOnEmpty()) {\r\n            root = parserFromJson.parse(this.file);\r\n            labWorks = root.getLabWorkSet();\r\n            this.helperController = new HelperController(this.file, getRoot());\r\n        } else {\r\n            this.helperController = new HelperController(this.file, getRoot());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Самый главный метод класса, а может и всей программы.\r\n     * Сперва в методе запускается статический метод help.execute\r\n     * Переменная flag нужна чтобы контролировать цикл while\r\n     * Проверяется наличие execute_script на вводе\r\n     * @throws IOException\r\n     */\r\n    public void start() throws IOException, ParseException {\r\n        if (getRoot().getValid()) {\r\n            setExecuteScript(new ExecuteScript(getHelperController()));\r\n            boolean flag = false;\r\n            help.execute();\r\n            while (!flag) {\r\n                String cmd = reformatCmd(reader.readLine()).trim();\r\n                String[] arr = cmd.split(\" \", 2);\r\n                if (arr[0].equals(\"execute_script\")) {\r\n                    getExecuteScript().execute(arr[1]);\r\n                }\r\n                searchCommandInCollection(cmd);\r\n\r\n                System.out.println(\"---------------------\");\r\n                System.out.println(\"? Если возникли трудности, введите команду help\");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * В параметры метода передается переменная типа String\r\n     * Цикл foreach проходит по каждому обьекту коллекции commandArrayList, чтобы найти нужную команду\r\n     *\r\n     * @param\r\n     */\r\n    public void searchCommandInCollection(String cmd) throws IOException, ParseException {\r\n\r\n        getHelperController().setReader(new BufferedReader(new InputStreamReader(System.in)));\r\n\r\n        NoInputCommands noInputCommands = new NoInputCommands(helperController);\r\n        setCommands(noInputCommands.getCommands());\r\n\r\n        InputCommands inputCommands = new InputCommands(helperController);\r\n        setInputCommands(inputCommands.getInputCommands());\r\n\r\n\r\n        //  No input commands\r\n        for (Map.Entry<String, Invoker> entry : getCommands().entrySet()) {\r\n            String key = entry.getKey();\r\n            if (cmd.equals(key)) {\r\n                System.out.println(\"Активирована команда \" + entry.getValue().getClass().getSimpleName());\r\n                entry.getValue().doCommand(cmd);\r\n            }\r\n        }\r\n\r\n        //если не было совпадений в первом мапе, пробегаемся по мапу команд с аргументами\r\n        for (Map.Entry<String, Invoker> entry : getInputCommands().entrySet()) {\r\n            String commandValue = \"\";\r\n            String commandKey = \"\";\r\n            if (cmd.contains(\" \")) {\r\n                String[] arr = cmd.split(\" \", 2);\r\n\r\n                commandKey = arr[0];\r\n                commandValue = arr[1];\r\n\r\n            } else {\r\n                commandKey = cmd;\r\n            }\r\n            String key = entry.getKey();\r\n            if (commandKey.equals(key)) {\r\n                System.out.println(\"Активирована команда \" + entry.getValue().getClass().getSimpleName());\r\n                entry.getValue().doCommand(commandValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод форматирует введенные данные, и преобразовывает в нужную форму.\r\n     * @param cmd\r\n     * @return\r\n     */\r\n    private String reformatCmd(String cmd) {\r\n        if (cmd != null && !checkOnExecuteScript(cmd)) {\r\n            if (cmd.contains(\" \")) {\r\n                String[] arr = cmd.split(\" \", 2);\r\n                cmd = arr[0].replaceAll(\"_\", \" \");\r\n                cmd = WordUtils.capitalize(cmd);\r\n                cmd = cmd.replaceAll(\" \", \"\");\r\n                cmd = cmd.concat(\" \" + arr[1]);\r\n            } else {\r\n                cmd = cmd.replaceAll(\"_\", \" \");\r\n                cmd = WordUtils.capitalize(cmd);\r\n                cmd = cmd.replaceAll(\" \", \"\");\r\n            }\r\n        } else {\r\n            return cmd;\r\n        }\r\n        return cmd;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет наличие в введенных данных команду execute_script\r\n     * Если execute_script, то выкидывается true, иначе false.\r\n     */\r\n    private boolean checkOnExecuteScript(String cmd) {\r\n        if (cmd != null) {\r\n            String[] arr = cmd.split(\" \", 2);\r\n            return Objects.equals(arr[0], \"execute_script\");\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public void setRoot(Root root) {\r\n        this.root = root;\r\n    }\r\n\r\n    public Root getRoot() {\r\n        return root;\r\n    }\r\n\r\n    public void setCommands(Map<String, Invoker> commands) {\r\n        this.commands = commands;\r\n    }\r\n\r\n    public Map<String, Invoker> getCommands() {\r\n        return commands;\r\n    }\r\n\r\n    public void setInputCommands(Map<String, Invoker> inputCommands) {\r\n        this.inputCommands = inputCommands;\r\n    }\r\n\r\n    public Map<String, Invoker> getInputCommands() {\r\n        return inputCommands;\r\n    }\r\n\r\n    public HelperController getHelperController() {\r\n        return helperController;\r\n    }\r\n\r\n    public ExecuteScript getExecuteScript() {\r\n        return executeScript;\r\n    }\r\n\r\n    public void setExecuteScript(ExecuteScript executeScript) {\r\n        this.executeScript = executeScript;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Controller{\" +\r\n                \"commands=\" + commands +\r\n                \", inputCommands=\" + inputCommands +\r\n                \", labWorks=\" + labWorks +\r\n                \", parserFromJson=\" + parserFromJson +\r\n                \", help=\" + help +\r\n                \", reader=\" + reader +\r\n                \", helperController=\" + helperController +\r\n                \", root=\" + root +\r\n                \", executeScript=\" + executeScript +\r\n                '}';\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/manager/Controller.java b/src/main/java/manager/Controller.java
--- a/src/main/java/manager/Controller.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/manager/Controller.java	(date 1680710471149)
@@ -39,13 +39,15 @@
      */
     public Controller(String file) throws IOException {
         this.file = file;
-        if (parserFromJson.checkOnEmpty()) {
+        if (parserFromJson.checkOnEmpty(this.file)) {
             root = parserFromJson.parse(this.file);
             labWorks = root.getLabWorkSet();
-            this.helperController = new HelperController(this.file, getRoot());
         } else {
-            this.helperController = new HelperController(this.file, getRoot());
-        }
+            root = new Root();
+            root.setValid(true);
+        }
+
+        this.helperController = new HelperController(this.file, getRoot());
     }
 
     /**
Index: src/main/java/command/commands/inputCommands/RemoveLowerElementCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package command.commands.inputCommands;\r\n\r\n\r\nimport command.Command;\r\nimport command.ElementCommand;\r\nimport manager.HelperController;\r\n\r\npublic class RemoveLowerElementCommand implements Command {\r\n    private HelperController helperController;\r\n\r\n    public RemoveLowerElementCommand(HelperController helperController) {\r\n        this.helperController = helperController;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        helperController.removeLower();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/command/commands/inputCommands/RemoveLowerElementCommand.java b/src/main/java/command/commands/inputCommands/RemoveLowerElementCommand.java
--- a/src/main/java/command/commands/inputCommands/RemoveLowerElementCommand.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/command/commands/inputCommands/RemoveLowerElementCommand.java	(date 1680365980743)
@@ -14,7 +14,7 @@
 
     @Override
     public void execute() {
-        helperController.removeLower();
+        //helperController.removeLower();
     }
 
 }
Index: src/main/java/parser/parserFromJson/ParserFromJson.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package parser.parserFromJson;\r\n\r\nimport object.Coordinates;\r\nimport object.LabWork;\r\nimport object.Person;\r\nimport object.enums.Color;\r\nimport object.enums.Difficulty;\r\nimport org.json.simple.JSONArray;\r\nimport org.json.simple.JSONObject;\r\nimport org.json.simple.parser.JSONParser;\r\nimport org.json.simple.parser.ParseException;\r\nimport parser.Root;\r\n\r\nimport java.io.*;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Метод парсит данные из json файла в коллекцию {@link Root#labWorkSet}\r\n * Ключевой метод для работы с коллекцией.\r\n */\r\n\r\npublic class ParserFromJson {\r\n\r\n\r\n\r\n    /**\r\n     * Метод обращается к файлу notes.json, использует его в качестве базы данных объектов.\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    public Root parse(String fileName) throws IOException {\r\n        Root root = new Root();\r\n        JSONParser parser = new JSONParser();\r\n        File file = new File(fileName);\r\n        if (file.exists())\r\n            try (InputStreamReader reader = new InputStreamReader(new FileInputStream(file))) {\r\n\r\n                JSONArray labsJsonArray = (JSONArray) parser.parse(reader);\r\n\r\n                HashSet<LabWork> labWorks = new HashSet<>();\r\n                for (Object lab : labsJsonArray) {\r\n                    JSONObject labJsonObject = (JSONObject) lab;\r\n\r\n                    // at the first parsing primitive type of json file\r\n                    long id = (Long) labJsonObject.get(\"id\");\r\n                    long minimalPoint = (Long) labJsonObject.get(\"minimalPoint\");\r\n                    long tunedInWorks = (Long) labJsonObject.get(\"tunedInWorks\");\r\n                    String name = (String) labJsonObject.get(\"name\");\r\n                    String creationDate = (String) labJsonObject.get(\"creationDateString\");\r\n                    String difficulty = (String) labJsonObject.get(\"difficulty\");\r\n\r\n                    // at the second parsing object type of json file\r\n                    //Coordinates type\r\n                    JSONObject coordinatesJsonObject = (JSONObject) labJsonObject.get(\"coordinates\");\r\n                    long x = (Long) coordinatesJsonObject.get(\"x\");\r\n                    double y = (Double) coordinatesJsonObject.get(\"y\");\r\n\r\n                    // Person type\r\n                    JSONObject personJsonObject = (JSONObject) labJsonObject.get(\"author\");\r\n                    String nameAuthor = (String) personJsonObject.get(\"name\");\r\n                    String color = (String) personJsonObject.get(\"eyeColor\");\r\n                    double height = (Double) personJsonObject.get(\"height\");\r\n                    String dataBirthday = (String) personJsonObject.get(\"birthday\");\r\n\r\n                    LabWork labWork = new LabWork((int) id, name, (int) minimalPoint, (int) tunedInWorks, Difficulty.valueOf(difficulty), new Coordinates((int) x, y), new Person(nameAuthor, Color.valueOf(color), height, dataBirthday), creationDate);\r\n\r\n                    labWorks.add(labWork);\r\n                }\r\n\r\n                root.setLabWorkSet(labWorks);\r\n\r\n                root.setValid(true);\r\n\r\n                return root;\r\n            } catch (ParseException | NullPointerException e) {\r\n                System.out.println(\"Невалидный файл json!\");\r\n                root.setValid(false);\r\n            }\r\n        return root;\r\n    }\r\n\r\n\r\n    /**\r\n     * Метод проверяет есть ли в файле обьекты коллекции.\r\n     * @return boolean\r\n     */\r\n    public boolean checkOnEmpty() {\r\n\r\n        try {\r\n            File file = new File(\"notes.json\");\r\n            BufferedReader br = new BufferedReader(new FileReader(file));\r\n\r\n            try {\r\n                if (br.readLine() == null)\r\n                    return false;\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n            return true;\r\n        } catch (Exception e) {\r\n            System.out.println(e);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/parser/parserFromJson/ParserFromJson.java b/src/main/java/parser/parserFromJson/ParserFromJson.java
--- a/src/main/java/parser/parserFromJson/ParserFromJson.java	(revision b22c6aa1d67dd71380d27107bdfeb2908e111f37)
+++ b/src/main/java/parser/parserFromJson/ParserFromJson.java	(date 1680371454470)
@@ -76,6 +76,10 @@
             } catch (ParseException | NullPointerException e) {
                 System.out.println("Невалидный файл json!");
                 root.setValid(false);
+            } catch(IllegalArgumentException | ClassCastException e) {
+                System.out.println("Проблема с парсингом из файла -->");
+                System.out.println(e.getMessage());
+                root.setValid(false);
             }
         return root;
     }
@@ -85,10 +89,10 @@
      * Метод проверяет есть ли в файле обьекты коллекции.
      * @return boolean
      */
-    public boolean checkOnEmpty() {
+    public boolean checkOnEmpty(String fileName) {
 
         try {
-            File file = new File("notes.json");
+            File file = new File(fileName);
             BufferedReader br = new BufferedReader(new FileReader(file));
 
             try {
@@ -100,10 +104,8 @@
 
             return true;
         } catch (Exception e) {
-            System.out.println(e);
-        }
-
-        return false;
+            return false;
+        }
     }
 
 }
